import sys
sys.path.append("../Utils/")

import argparse as ap
from Utils_EditPaths import *

def Job(args):
	fasta_file1 = args[0]
	fasta_file2 = args[1]
	rank = args[2]
	blast_out = args[3]
	edit_path_dir = args[4]
	Prog_RDP = args[5]
	RDP_DB = args[6]
	edit_path_taxadir = args[7]
	summary_dir = args[8]
	npath = args[9]
	align_thresh = args[10]

	Run_BLAST(fasta_file1, fasta_file2, blast_out)
	flag, BLAST_Hit = Validate_BLAST_Hits(blast_out, align_thresh)
	if(flag == False):
		print('Poor quality BLAST Hit')
		remove(blast_out)
		return

	if not isdir(edit_path_dir+rank+'/'):
		mkdir(edit_path_dir+rank+'/')

	blast_dir, blast_file = split(blast_out)
	edit_path_seqs = edit_path_dir+rank+'/'+blast_file.replace(".json",".fasta")

	editPath(BLAST_Hit, edit_path_seqs, npath)
	if not isfile(edit_path_seqs):
		print("Error running edit path...", blast_file.replace(".json",""))
		return
	
	if not isdir(edit_path_taxadir+rank+'/'):
		mkdir(edit_path_taxadir+rank+'/')
	edit_path_taxa = edit_path_taxadir+rank+'/'+blast_file.replace(".json",".tax.out")
	Run_Classifier((Prog_RDP, edit_path_seqs, RDP_DB, edit_path_taxa))
	if not isfile(edit_path_taxa):
		print("Error Running RDP Classifier on ", edit_path_seqs)
		return
	
	if not isdir(summary_dir+rank+'/'):
		mkdir(summary_dir+rank+'/')
	summary_file_path = summary_dir+rank+'/'+blast_file.replace(".json",".csv")
	Summarize_Paths(edit_path_seqs, edit_path_taxa, summary_file_path)
	
	if not isfile(summary_file_path):
		print("Error Summarizing Paths....", edit_path_taxa)
		return

if __name__ == "__main__":
	parser = ap.ArgumentParser(description = "This is a script to generate edit paths between pairs of taxa "+ 
											 "that have the same family level classification label. This "+
											 "script takes the batch parameters generated by running the "+
											 "Make_Edit_Batches.py script as input.")

	parser.add_argument("-i", "--input", help="The text file containing parameters for generating different edit paths.", required=True)
	parser.add_argument("-o", "--output", help="Directory to write outputs to.", required=True)
	parser.add_argument("-t","--threads", help = "number of threads to run concurrently. (Default = 16)", required = False, default = "16")
	parser.add_argument("-n","--number_of_editpaths", help = "Number of edit paths to sample. (Default = 10)", required = False, default = "10")
	parser.add_argument("-a","--alignlen", help = "fraction of query coverage to consider for generating edit paths. (Default = 0.85)", required = False, default = "0.85")
	parser.add_argument("-rdp", "--rdp_classifier", help="Directory containing the RDP classifier program.", required=True)
	parser.add_argument("-db", "--rdp_DB", help = "Directory containing the trained RDP classifier.", required=True)
	

	args = parser.parse_args()

	input_file = args.input
	out_dir = args.output
	Prog_RDP = args.rdp_classifier #'/fs/cbcb-scratch/hsmurali/RDP_Outlier_Analysis/RDPTools/'
	RDP_DB = args.rdp_DB #'/fs/cbcb-lab/mpop/projects/RDP_Outlier_Analysis/RDP_Database/rRNAClassifier.properties'
	npaths = int(args.number_of_editpaths)
	align_thresh = float(args.alignlen)
	threads = int(args.threads)
	if not isdir(out_dir):
		try:
			mkdir(out_dir)
		except OSError:
			print('Unable to create '+out_dir)
			sys.exit(1)

	edit_path_dir = out_dir + 'Edit_Paths/'
	if not isdir(edit_path_dir):
		try: mkdir(edit_path_dir)
		except OSError:
			print('Unable to create '+edit_path_dir)
			sys.exit(1)

	edit_path_taxadir = out_dir + 'Edit_Paths_Taxa/'
	if not isdir(edit_path_taxadir):
		try: mkdir(edit_path_taxadir)
		except OSError:
			print('Unable to create '+edit_path_taxadir)
			sys.exit(1)

	summary_dir = out_dir + 'Edit_Paths_Summary/'
	if not isdir(summary_dir):
		try: mkdir(summary_dir)
		except OSError:
			print('Unable to create '+summary_dir)
			sys.exit(1)

	arguments = []
	#b += (edit_path_dir, Prog_RDP, RDP_DB, edit_path_taxadir, summary_dir, npaths, align_thresh)
	Jobs = open(input_file).readlines()
	for j in Jobs:
		b = eval(j.replace("\n",""))
		b += (edit_path_dir, Prog_RDP, RDP_DB, edit_path_taxadir, summary_dir, npaths, align_thresh)
		arguments.append(b)

	pool = multiprocessing.Pool(threads)
	result = pool.map(func=Job, iterable=arguments)
	pool.close()
	pool.join()